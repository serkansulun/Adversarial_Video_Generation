import torch
import torch.nn as nn

import constants as c

upsample = nn.Upsample(scale_factor=2, mode='bilinear')


class GeneratorModel(nn.Module):
    def __init__(self):
        super(GeneratorModel, self).__init__()
        conv_bias = not c.BATCH_NORM
        self.ws = []
        for scale_num in xrange(c.NUM_SCALE_NETS):
            scale_ws = []
            # create weights for kernels
            for i in xrange(len(c.SCALE_KERNEL_SIZES_G[scale_num])):
                if i == len(c.SCALE_KERNEL_SIZES_G[scale_num]) - 1:
                    scale_ws.append(nn.Conv2d(c.SCALE_FMS_G[scale_num][i],
                                              c.SCALE_FMS_G[scale_num][i + 1],
                                              c.SCALE_KERNEL_SIZES_G[scale_num][i],
                                              padding=c.SCALE_PADDING_SIZES_G[scale_num][i],
                                              bias=True))
                    scale_ws.append(nn.Tanh())
                else:
                    scale_ws.append(nn.Conv2d(c.SCALE_FMS_G[scale_num][i],
                                              c.SCALE_FMS_G[scale_num][i + 1],
                                              c.SCALE_KERNEL_SIZES_G[scale_num][i],
                                              padding=c.SCALE_PADDING_SIZES_G[scale_num][i],
                                              bias=conv_bias))
                    scale_ws.append(nn.LeakyReLU(c.LEAK))
                    if c.BATCH_NORM:
                        scale_ws.append(nn.BatchNorm2d(c.SCALE_FMS_G[scale_num][i + 1]))

            self.ws.append(nn.Sequential(*scale_ws))
            # add to trainable parameters

        self.ws = nn.Sequential(*self.ws)

    def forward(self, input_):

        preds = []
        for scale_num in xrange(c.NUM_SCALE_NETS):
            # for all scales but the first, add the frame generated by the last scale to the input
            if scale_num > 0:
                single_scale_preds = upsample(single_scale_preds)
                single_scale_preds = torch.cat([input_[scale_num], single_scale_preds], 1)
            else:
                single_scale_preds = input_[scale_num]

            single_scale_preds = self.ws[scale_num](single_scale_preds)  # forward pass

            preds.append(single_scale_preds)

        return preds

